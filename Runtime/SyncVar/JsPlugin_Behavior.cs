using UnityEngine;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;              // TODO: move this into the #if UNITY_EDITOR block and wrap dependent code below it
using System.Text.RegularExpressions; // TODO: include as many of these similarly as we can

#if UNITY_EDITOR
  using UnityEditor;
#endif

namespace Multisynq {

//=================== |||||||||||||||||| ================
abstract public class JsPlugin_Behaviour : MonoBehaviour {

  static public string logPrefix = "[%ye%Js%cy%Plugin%gy%]".TagColors();
  static bool dbg = true;
  abstract public JsPluginCode GetJsPluginCode(); // not static since this must find scene MonoBehaviours
  static public string[] CodeMatchPatterns() => new string[]{"You should define CodeMatchPatterns() in your subclass of JsPlugin_Behaviour"};  

  #if UNITY_EDITOR
    //------------------ ||||||||||||||||||||||||| -------------------------
    static public string MakeIndexOfPlugins_JsCode( List<JsPluginCode> jsPluginCodes ) {
      string imports = "";
      string modelInits = "";
      string viewInits = "";
      foreach( JsPluginCode plugCode in jsPluginCodes) {
        string[] expts    = plugCode._pluginExports;
        string exptsStr   = string.Join(", ", expts);
        string plugNm     = plugCode._pluginName;
        bool hasView  = expts.Contains(plugNm+"_View");
        bool hasModel = expts.Contains(plugNm+"_Model");

        imports                  += $"        import {{ {exptsStr} }} from './{plugNm}'\n";
        if (hasModel) modelInits += $"            this.plugins['{plugNm}_Model'] = {plugNm}_Model.create({{}})\n";
        if (hasView) viewInits   += $"            this.plugins['{plugNm}_View'] = new {plugNm}_View(model.plugins['{plugNm}_Model'])\n";
      }

      string code =  $@"
        // DO NOT EDIT THIS GENERATED FILE, please.  =]
        // This file is generated by M4U's JsPlugin_Behaviour.cs
        import {{ GameModelRoot }} from '@croquet/game-models';
        import {{ GameViewRoot }} from '@croquet/unity-bridge';

        // ######## imports generated from each JsPlugin_Behavior.cs subclass
{imports.Trim('\n')}
        // ########

        //========== |||||||||||||||| =================================================================
        export class PluginsModelRoot extends GameModelRoot {{
          plugins={{}}
          init(options) {{
            // @ts-ignore
            super.init(options);

            // ######## modelInits
{modelInits.Trim('\n')}
            // ########

          }}
        }}
        // @ts-ignore
        PluginsModelRoot.register('PluginsModelRoot');
        
        //========== ||||||||||||||| =================================================================
        export class PluginsViewRoot extends GameViewRoot {{
          plugins={{}}
          constructor(model) {{
            super(model);

            // ######### viewInits
{viewInits.Trim('\n')}
            // #########

          }}
          detach() {{ 
            Object.values(this.plugins).forEach(plugin => plugin.detach());
            super.detach(); 
          }}
        }}
      ".LessIndent();
      return code;
    }
    //---------------- ||||||||||||||||||||||| -------------------------
    public static void GenerateIndexOfPluginsFile(List<JsPluginCode> jsPluginCodes) {
      var plugFldr = Mq_File.AppPluginsFolder();
      var outp = plugFldr.DeeperFile("indexOfPlugins.js");
      outp.WriteAllText(MakeIndexOfPlugins_JsCode(jsPluginCodes));
    }
    //------------------ ||||||||||| -------------------------
    public static string IndexJsCode = @$"
      import {{ StartSession }} from '@croquet/unity-bridge'
      import {{ PluginsModelRoot, PluginsViewRoot }} from './plugins/indexOfPlugins'
      import {{ BUILD_IDENTIFIER }} from './buildIdentifier'
      StartSession(PluginsModelRoot, PluginsViewRoot, BUILD_IDENTIFIER)
      ".LessIndent();
    //---------------- |||||||||||||||||||||||||||| -------------------------
    public static void PrependPluginCodeAndWrapExistingCodeInCommentMarkers() {
      var idxFile = Mq_File.AppFolder().DeeperFile("index.js");
      var code = idxFile.ReadAllText();
      code = IndexJsCode + "\n\n\n" + code;
      code = "/*\n" + code + "\n*/";
      idxFile.WriteAllText(code);
    }
    //---------------- |||||||||||||||||||||||||||| -------------------------
    public static bool CheckIndexJsForPluginsImport() {
      var idxFile = Mq_File.AppFolder().DeeperFile("index.js");
      var code = (idxFile.Exists()) ? idxFile.ReadAllText() : "";
      // expect these to be in the file: "PluginsModelRoot", "PluginsViewRoot"
      bool isOk = code.Contains("PluginsModelRoot") && code.Contains("PluginsViewRoot");
      if (!isOk) {
        Debug.LogError(@$"{logPrefix} Missing the 'PluginsModelRoot' and 'PluginsViewRoot' in {idxFile.shortPath} Needed code: --->
          {IndexJsCode}" + "\n\n\n"
        );
      }
      return isOk;
    }

    //------------------ |||||||||||||||||||||||||||||| -------------------------
    public static string MakeTemplateDataFromSubclasses() {

      var subclasses = typeof(JsPlugin_Behaviour).GetSubclassTypes();

      string[] varsForType(Func<Type, string> formatter) {
        return subclasses.Select(formatter).ToArray();
      }

      string[] imports = varsForType(clz => 
        $"{{ vars: '{{ {clz.Name}_Model, {clz.Name}_View }}', file: './{clz.Name}' }},"
      );
      string[] models  = varsForType(clz => 
        $"{{ modelClass: '{clz.Name}_Model' }},"
      );
      string[] views   = varsForType(clz => 
        $"{{ viewClass: '{clz.Name}_View', modelClass: '{clz.Name}_Model' }},"
      );

      string templateDataJsCode = $@"
        const templateData = {{

          imports: [
            // data here:  {{ vars: '{{ SynqClones_Mgr_Model }}', file: './SynqClones_Mgr' }},
            // becomes:    import {{SynqClones_Mgr_Model}} from './SynqClones_Mgr'
            {string.Join('\n', imports)}
          ],

          modelInits: [
            // data here: {{modelClass: 'SynqCommand_Mgr_Model'}},
            // becomes:  this.plugins['{{modelClass}}'] = {{modelClass}}.create({{}})
            {string.Join('\n', models)}
          ],

          viewInits: [
            // data here: {{ viewClass: 'SynqVar_Mgr_View', modelClass: 'SynqVar_Mgr_Model' }},
            // becomes:   this.plugins['{{viewClass}}'] = new {{viewClass}}(model.plugins['{{modelClass}}'])
            {string.Join('\n', views)}
          ]

        }};
        module.exports = {{ templateData }};
      ";
      return templateDataJsCode;
    }

  #endif

  #if !UNITY_EDITOR
    virtual public void WriteJsPluginCode() { }
  #endif

  virtual public void Start() {
    #if UNITY_EDITOR
      CheckIfMyJsCodeIsPresent();
    #endif
  }

  #if UNITY_EDITOR

    virtual public void WriteJsPluginCode() {
        // if (dbg) Debug.Log($"{logPrefix} <color=white>BASE</color> virtual public void WriteJsPluginCode()");
        var jsPlugin = GetJsPluginCode();
        var file = Mq_File.AppPluginsFolder().EnsureExists().DeeperFile(jsPlugin._pluginName+".js");
        file.WriteAllText(jsPlugin._pluginCode);
        Debug.Log($"{logPrefix} Wrote %gr%{file.shortPath}%gy%".Replace(jsPlugin._pluginName, $"%ye%{jsPlugin._pluginName}%gr%").TagColors());  
    }

    public void CheckIfMyJsCodeIsPresent() {
        var jsPlugin = GetJsPluginCode();
        var modelClassPath = Mq_File.AppFolder().DeeperFile($"plugins/{jsPlugin._pluginName}.js");
        if (modelClassPath.Exists()) {
            Debug.Log($"{logPrefix} '{jsPlugin._pluginName}.js' already present at '{modelClassPath.longPath}'");
        } else {
            modelClassPath.SelectAndPing();
            Debug.LogError($"   v");
            Debug.LogError($"   v");
            Debug.LogError($"   v");
            Debug.LogError($"MISSING JS FILE {jsPlugin._pluginName}.js for {this.GetType().Name}.cs");
            Debug.LogError($"   ^");
            Debug.LogError($"   ^");
            Debug.LogError($"   ^");
            EditorApplication.isPlaying = false;
        }
    }

    public static void WriteAllJsPlugins() {
      var az = AnalyzeAllJsPlugins();
      var allPluginTypes = az.neededTs;
      Debug.Log($"%mag%WRITE ALL%gy%{az.neededOnesTxt}".TagColors());
      WriteJsPlugins( allPluginTypes.ToList() );
    }

    public static void WriteJsPlugins(List<Type> jsPluginTypes) {
      var jpcs = jsPluginTypes.Select(jcp => InjectOneJsPlugin(jcp).GetJsPluginCode()).ToList();
      GenerateIndexOfPluginsFile(jpcs); // Also sync the indexOfPlugins file
    }

    public static void WriteMissingJsPlugins() {
      var missingPluginTypes = AnalyzeAllJsPlugins().tsMissingSomePart;
      WriteJsPlugins( missingPluginTypes.ToList() );
    }

    static public JsPlugin_Behaviour InjectOneJsPlugin( Type jsPluginType ) {
      var jsPluginMB = Singletoner.EnsureInstByType(jsPluginType) as JsPlugin_Behaviour;
      Debug.Log($"{logPrefix} Ensured GameObject with a '%ye%{jsPluginType.Name}%gy%' on it.".TagColors(), jsPluginMB.gameObject);  
      jsPluginMB.WriteJsPluginCode();
      return jsPluginMB;
    }

    static public bool JsFileForThisClassTypeExists(Type jsPluginType) {
      if (!typeof(JsPlugin_Behaviour).IsAssignableFrom(jsPluginType)) {
        Debug.LogError($"{logPrefix} JsFileForThisClassTypeExists() called with a non-JsCodeInjecting_MonoBehaviour subclass: {jsPluginType.Name}");
        return false;
      }

      var jsPluginMB = (JsPlugin_Behaviour)jsPluginType.GetMethod("I")?.Invoke(null, null);
      if (jsPluginMB == null) {
        Debug.LogError($"{logPrefix} JsFileForThisClassTypeExists() could not find a GetJsPluginCode() method for {jsPluginType.Name}");
        return false;
      }
      var jsPlugin = jsPluginMB.GetJsPluginCode();
      var modelClassPath = Mq_File.AppFolder().DeeperFile($"plugins/{jsPlugin._pluginName}.js");
      return modelClassPath.Exists();
    }
    //========== |||||||||||||| ====================
    public class JsPluginReport {
      public HashSet<Type> neededTs                  = new();
      public HashSet<Type> missingSceneInstancesOfTs = new();
      public HashSet<Type> haveSceneInstancesOfTs    = new();
      public HashSet<Type> tsThatAreReady            = new();
      public HashSet<Type> tsMissingSomePart         = new();
      public HashSet<string> filesThatNeedPlugins    = new();
      public HashSet<string> filesThatAreReady       = new();
      public HashSet<string> filesMissingPlugins     = new();
      public string needTxt;
      public string neededOnesTxt;
      public string haveInstOnesTxt;
      public string haveJsFileOnesTxt;
      public string missingPartOnesTxt;

    }
    //-------------------------- ||||||||||||||||||| ----------------------------------------
    static public JsPluginReport AnalyzeAllJsPlugins() {

      JsPluginReport rpt = new();

      // 0. For each SynqBehavior
      // 1. Read the script file
      // 2. Check if it contains a pattern that needs a JsPlugin
      // 3. If it does, add the JsPlugin to the neededPlugins list
      // 4. Check if the class has an instance in the scene
      // 5. Continue if not in scene since we cannot get the JsPluginFileName() method from a non-instance
      // 6. Call JsPluginFileName() method for this class
      // 7. Check if the file exists

      // 0. For each SynqBehavior
      foreach (var behaviour in FindObjectsOfType<SynqBehaviour>(false)){ // false means we skip inactives
        // 1. Read the SynqBehavior script file
        MonoScript synqBehScript = MonoScript.FromMonoBehaviour(behaviour);
        string            sbPath = AssetDatabase.GetAssetPath(synqBehScript);
        string       synqBehCode = synqBehScript.text;
        if (synqBehCode == null) {
          Debug.LogError($"{logPrefix} FindMissingJsPluginTypes() found a SynqBehaviour with no script: {behaviour.name}");
          continue;
        }
        Dictionary<Type, string[]> codeMatchesByJsPlugin = 
          typeof(JsPlugin_Behaviour).DictOfSubclassStaticMethodResults<string[]>( "CodeMatchPatterns" );

        // 2. Check if it contains a pattern that needs a JsPlugin
        foreach (var (jsPluginType, codeMatches) in codeMatchesByJsPlugin) {
          foreach (string codeMatchRegex in codeMatches) {
            if (Regex.IsMatch(synqBehCode, codeMatchRegex)) {
              // 2.5 ensure it is not inside a comment
              // if (Regex.IsMatch(sbScript.text, @"//.*" + pattern)) continue; // TODO: add this and test it

              // 3. If it does, add the JsPlugin to the neededPlugins list
              rpt.neededTs.Add(jsPluginType);
              string sbPathAndPattern = $"{sbPath}<color=grey> needs: </color> <color=yellow>{jsPluginType}</color> for: <color=white>{(codeMatchRegex.Replace("\\",""))}</color>";
              rpt.filesThatNeedPlugins.Add(sbPathAndPattern);
              // 4. Check if the class has an instance in the scene
              var jsPluginInstance = (JsPlugin_Behaviour)FindObjectOfType(jsPluginType);
              // 5. Continue if not in scene since we cannot get the JsPluginFileName() method from a non-instance. 
              // Also continue if it is disabled
              if (jsPluginInstance == null || !jsPluginInstance.enabled) {
                rpt.missingSceneInstancesOfTs.Add(jsPluginType);
                continue;
              }
              rpt.haveSceneInstancesOfTs.Add(jsPluginType);
              // 6. Call JsPluginFileName() method for this class
              string jsPluginFileName = $"plugins/{jsPluginInstance.GetJsPluginCode()._pluginName}.js";
              // 7. Check if the file exists
              var modelClassPath = Mq_File.AppFolder().DeeperFile(jsPluginFileName);
              if (modelClassPath.Exists()) {
                rpt.tsThatAreReady.Add(jsPluginInstance.GetType());
                rpt.filesThatAreReady.Add(sbPathAndPattern);
              }
            } // if IsMatch
          } // foreach codeMatchPatterns
        } // foreach codeMatchPatternsByJsPlugin
      } // foreach SynqBehaviour
      rpt.tsMissingSomePart   = rpt.neededTs.Except(rpt.tsThatAreReady).ToHashSet();
      rpt.filesMissingPlugins = rpt.filesThatNeedPlugins.Except(rpt.filesThatAreReady).ToHashSet();
      // lambda for report text from List
      var rptList = new System.Func<HashSet<System.Type>, string>((types) => {
        return "[ " + string.Join(", ", types.Select(x => $"%ye%{x.Name}%gy%")) + " ]";
      });
      // lambda for report text "Count:%cy%{A.Length}%gy% of %cy%{B.Count}%gy%
      var countOfCount = new System.Func<HashSet<System.Type>, HashSet<System.Type>, string>((A, B) => {
        return $"Count:%cy%{A.Count}%gy% of %cy%{B.Count}%gy%";
      });
      string rptMissings = rptList(rpt.missingSceneInstancesOfTs);
      string rptAOKs     = rptList(rpt.tsThatAreReady);
      string rptNeededs  = rptList(rpt.neededTs);
      string rptHaves    = rptList(rpt.haveSceneInstancesOfTs);
      rpt.neededOnesTxt          = $"{logPrefix} %cy%{rpt.neededTs.Count}%gy% needed JsPlugins: {rptNeededs}".TagColors();
      rpt.haveInstOnesTxt        = $"{logPrefix} {countOfCount(rpt.haveSceneInstancesOfTs, rpt.neededTs)} JsPlugins %gre%have%gy% an instance in scene: {rptHaves}".TagColors();
      rpt.haveJsFileOnesTxt      = $"{logPrefix} {countOfCount(rpt.tsThatAreReady,         rpt.neededTs)} JsPlugins are %gre%ready%gy% to go: {rptAOKs}".TagColors();
      rpt.missingPartOnesTxt     = $"{logPrefix} {countOfCount(rpt.tsMissingSomePart,      rpt.neededTs)} JsPlugins are %red%MISSING%gy% a part: {rptList(rpt.tsMissingSomePart)}".TagColors();
      return rpt;
    }
    //---------------- ||||||||||||||||| ----------------------------------------
    public static bool LogJsPluginReport(JsPluginReport pluginRpt) {
      // lambda function for report text from List
      var rptList = new System.Func<HashSet<System.Type>, string>((types) => {
        return "[ " + string.Join(", ", types.Select(x => $"<color=yellow>{x.Name}</color>")) + " ]";
      });

      var fldr = $"<color=#ff55ff>Assets/MultisynqJS/{Mq_File.GetAppNameForOpenScene()}/plugins/</color>";
      int missingCnt = pluginRpt.tsMissingSomePart.Count;
      int neededCnt = pluginRpt.neededTs.Count;
      bool amMissingPlugins = pluginRpt.tsMissingSomePart.Count > 0;
      if (amMissingPlugins) {
        Debug.Log(pluginRpt.neededOnesTxt);
        Debug.Log(pluginRpt.haveInstOnesTxt);
        Debug.Log(pluginRpt.haveJsFileOnesTxt);
        // for each missing file, log the file
        foreach (var missingFile in pluginRpt.filesMissingPlugins) {
          Debug.Log($"|    Missing its Js Plugin: <color=#ff7777>{missingFile}</color>");
        }
        // for all ready files, log the file
        foreach (var readyFile in pluginRpt.filesThatAreReady) {
          Debug.Log($"|    Js Plugin is ready for: <color=#55ff55>{readyFile}</color>");
        }
        // Debug.Log(pluginRpt.missingPartOnesTxt);
        Debug.Log($"| <color=#ff5555>MISSING</color>  <color=cyan>{missingCnt}</color> of <color=cyan>{neededCnt}</color> JS Plugins: {rptList(pluginRpt.tsMissingSomePart)} in {fldr}");
        Debug.Log($"|    To Add Missing JS Plugin Files, in Menu:");
        Debug.Log($"|    <color=white>Croquet > Open Build Assistant Window > [Check If Ready], then [Add Missing JS Plugin Files]</color>");
      }
      else {
        Debug.Log($"All needed JS Plugins found in {fldr}: {rptList(pluginRpt.neededTs)}");
      }

      return amMissingPlugins;
    }
  #endif
}


} // namespace MultisynqNS